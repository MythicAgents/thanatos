package builder

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	agentstructs "github.com/MythicMeta/MythicContainer/agent_structs"
	_ "github.com/MythicMeta/MythicContainer/logging"
	"golang.org/x/exp/slices"
)

var builtinCommands = []string{
	"exit",
	"sleep",
	"link",
	"socks",
	"get-workinghours",
	"workinghours",
	"profiles",
	"disable-profile",
	"enable-profile",
	"load",
	"unload",
	"execution-method",
	"get-execution-method",
	"spawnto",
	"get-spawnto",
	"list-loaded",
}

var buildLock sync.Mutex

func parseWorkingHours(workingHours string) (int, int, error) {
	workingHoursSplit := strings.Split(workingHours, "-")

	workingStartStr := workingHoursSplit[0]
	workingStartSplit := strings.Split(workingStartStr, ":")

	workingStartHours, err := strconv.Atoi(workingStartSplit[0])
	if err != nil {
		return 0, 0, err
	}

	workingStartMinutes, err := strconv.Atoi(workingStartSplit[1])
	if err != nil {
		return 0, 0, err
	}

	workingStart := (workingStartHours * 3600) + (workingStartMinutes * 60)

	workingEndStr := workingHoursSplit[1]
	workingEndSplit := strings.Split(workingEndStr, ":")

	workingEndHours, err := strconv.Atoi(workingEndSplit[0])
	if err != nil {
		return 0, 0, err
	}

	workingEndMinutes, err := strconv.Atoi(workingEndSplit[1])
	if err != nil {
		return 0, 0, err
	}

	workingEnd := (workingEndHours * 3600) + (workingEndMinutes * 60)

	return workingStart, workingEnd, nil
}

func buildPayload(payloadBuildMsg agentstructs.PayloadBuildMessage) agentstructs.PayloadBuildResponse {
	payloadBuildResponse := agentstructs.PayloadBuildResponse{
		PayloadUUID:        payloadBuildMsg.PayloadUUID,
		Success:            false,
		UpdatedCommandList: &payloadBuildMsg.CommandList,
	}

	if len(payloadBuildMsg.C2Profiles) > 1 {
		for _, profile := range payloadBuildMsg.C2Profiles {
			if profile.IsP2P {
				payloadBuildResponse.BuildStdErr = "Cannot include a P2P C2 profile with multiple profiles."
				return payloadBuildResponse
			}
		}
	} else if len(payloadBuildMsg.C2Profiles) == 0 {
		payloadBuildResponse.BuildStdErr = "No C2 profiles specified."
		return payloadBuildResponse
	}

	output, err := payloadBuildMsg.BuildParameters.GetStringArg("output")
	if err != nil {
		payloadBuildResponse.BuildStdErr = "Failed to get the payload output."
		return payloadBuildResponse
	}
	if payloadBuildMsg.BuildParameters["output"].(string) == "shellcode" &&
		payloadBuildMsg.SelectedOS == agentstructs.SUPPORTED_OS_LINUX {
		payloadBuildResponse.BuildStdErr = "Cannot build shellcode for Linux."
		return payloadBuildResponse
	}

	buildParameters := map[string]string{}
	features := []string{}

	buildParameters["UUID"] = payloadBuildMsg.PayloadUUID

	for _, profile := range payloadBuildMsg.C2Profiles {
		for key, value := range profile.Parameters {
			parameterName := fmt.Sprintf("%s_%s", profile.Name, key)

			if key == "AESPSK" {
				cryptoval := value.(map[string]interface{})

				if cryptoval["value"] != "none" {
					features = append(features, fmt.Sprintf("%s_AES", profile.Name))
					buildParameters["AESKEY"] = fmt.Sprintf("%s", cryptoval["enc_key"])
				}
			} else if key == "callback_host" {
				callback_host := strings.TrimSuffix(value.(string), "/")

				features = append(features, "http")
				if strings.HasPrefix(callback_host, "http://") {
					features = append(features, "egress-profile?/http")
				} else if strings.HasPrefix(callback_host, "https://") {
					features = append(features, "egress-profile?/https")
				}

				buildParameters[parameterName] = strings.TrimSuffix(value.(string), "/")

			} else if key == "encrypted_exchange_check" {
				if value.(bool) {
					features = append(features, fmt.Sprintf("%s_EKE", profile.Name))
				}

			} else if key == "killdate" {
				ts, err := time.Parse(time.DateOnly, value.(string))
				if err != nil {
					payloadBuildResponse.BuildStdErr = fmt.Sprintf("Failed to parse killdate: %v", err)
					return payloadBuildResponse
				}

				buildParameters[parameterName] = fmt.Sprint(ts.Unix())

			} else if key == "headers" {
				headers, _ := json.Marshal(value)
				headerString := strings.ReplaceAll(string(headers), "'", "\\'")

				buildParameters[parameterName] = headerString
			} else {
				val := fmt.Sprintf("%v", value)

				if len(val) > 0 {
					buildParameters[parameterName] = val
				}

			}
		}
	}

	if len(buildParameters["http_proxy_host"]) > 0 {
		features = append(features, "proxy")
	}

	if !slices.Contains(features, "http") {
		features = append(features, "tcp")
	}

	if payloadBuildMsg.BuildParameters["tlsselfsigned"].(bool) {
		features = append(features, "egress-profile?/self-signed-certs")
	}

	var triple string
	switch payloadBuildMsg.BuildParameters["architecture"].(string) {
	case "x86_64":
		triple = "x86_64"
	case "x86":
		triple = "i686"
	}

	opensslFlags := ""
	if payloadBuildMsg.SelectedOS == agentstructs.SUPPORTED_OS_LINUX {
		target := "-unknown-linux-gnu"
		switch payloadBuildMsg.BuildParameters["static"].(string) {
		case "full":
			target = "-unknown-linux-musl"
		case "none":
			opensslFlags = "OPENSSL_NO_VENDOR=1"
		}

		triple += target
	} else {
		triple += "-pc-windows-gnu"
	}

	switch payloadBuildMsg.BuildParameters["initoptions"].(string) {
	case "Spawn Thread (Windows Only)":
		if payloadBuildMsg.SelectedOS == agentstructs.SUPPORTED_OS_WINDOWS {
			features = append(features, "spawnthread")
		}
	case "Daemonize (Linux Only)":
		if payloadBuildMsg.SelectedOS == agentstructs.SUPPORTED_OS_LINUX {
			features = append(features, "forkonexec")
		}
	}

	switch payloadBuildMsg.BuildParameters["exitfunction"].(string) {
	case "Exit Process":
		features = append(features, "exitprocess")
	case "Exit Thread (Windows Only)":
		if payloadBuildMsg.SelectedOS == agentstructs.SUPPORTED_OS_WINDOWS {
			features = append(features, "exitthread")
		}
	}

	buildParameters["connection_retries"] = fmt.Sprint(int(payloadBuildMsg.BuildParameters["connection_retries"].(float64)))

	workingStart, workingEnd, err := parseWorkingHours(payloadBuildMsg.BuildParameters["working_hours"].(string))
	if err != nil {
		payloadBuildResponse.BuildStdErr = fmt.Sprintf("Failed to parse working hours: %v", err)
		return payloadBuildResponse
	}

	if workingStart >= workingEnd {
		payloadBuildResponse.BuildStdErr = fmt.Sprintf("Invalid working hours. Start time is greater than or equal to the end time. %d-%d", workingStart, workingEnd)
		return payloadBuildResponse
	}

	buildParameters["working_hours"] = fmt.Sprintf("%d-%d", workingStart, workingEnd)

	if len(payloadBuildMsg.BuildParameters["domain"].(string)) > 0 {
		buildParameters["domain"] = payloadBuildMsg.BuildParameters["domain"].(string)
		features = append(features, "domain")
	}

	if len(payloadBuildMsg.BuildParameters["hostname"].(string)) > 0 {
		buildParameters["hostname"] = payloadBuildMsg.BuildParameters["hostname"].(string)
		features = append(features, "hostname")
	}

	if len(payloadBuildMsg.BuildParameters["username"].(string)) > 0 {
		buildParameters["username"] = payloadBuildMsg.BuildParameters["username"].(string)
		features = append(features, "username")
	}

	if payloadBuildMsg.BuildParameters["cryptolib"].(string) == "internal" {
		features = append(features, "cryptinternal")
	}

	commandString := "env \\\n"
	for key, val := range buildParameters {
		commandString += fmt.Sprintf("\t%s='%s' \\\n", key, val)
	}

	buildFlag := ""
	output := payloadBuildMsg.BuildParameters["output"].(string)
	if strings.Contains(output, "shared library") {
		buildFlag = "--lib"
		features = append(features, "library")

		if strings.Contains(output, "run on load") {
			features = append(features, "ctor")
		}
	} else {
		buildFlag = "--bin thanatos"
	}

	for _, command := range payloadBuildMsg.CommandList {
		if !slices.Contains(builtinCommands, command) {
			features = append(features, command)
		}
	}

	cargoCommand := []string{
		opensslFlags,
		"cargo build --release",
		buildFlag,
		fmt.Sprintf("--target %s", triple),
		fmt.Sprintf("--features %s", strings.Join(features, ",")),
	}

	cargoCommandFinal := []string{}

	for _, value := range cargoCommand {
		if len(value) > 0 {
			cargoCommandFinal = append(cargoCommandFinal, value)
		}
	}

	commandString += "\t" + strings.Join(cargoCommandFinal, " ")
	payloadBuildResponse.BuildMessage = commandString

	cmd := exec.Command("/bin/bash", []string{"-c", commandString}...)
	cmd.Dir = "thanatos/agent_code/"

	var stdout bytes.Buffer
	cmd.Stdout = &stdout

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	buildLock.Lock()
	if err := cmd.Run(); err != nil {
		buildLock.Unlock()
		payloadBuildResponse.BuildMessage = "Failed to build the payload. Check build errors for more info"
		payloadBuildResponse.BuildStdErr = stderr.String() + "\n" + err.Error()
		payloadBuildResponse.BuildStdOut = commandString
		if stdout.Len() > 0 {
			payloadBuildResponse.BuildStdOut += "\n" + stdout.String()
		}

		return payloadBuildResponse
	}

	if stdout.Len() > 0 {
		payloadBuildResponse.BuildStdOut = stdout.String()
	}

	if stderr.Len() > 0 {
		payloadBuildResponse.BuildStdErr = stderr.String()
	}

	filename := payloadBuildMsg.Filename
	if len(filename) == 0 {
		filename = "thanatos"
	}

	payloadPath := fmt.Sprintf("./thanatos/agent_code/target/%s/release/", triple)
	if strings.Contains(output, "executable") {
		if payloadBuildMsg.SelectedOS == agentstructs.SUPPORTED_OS_LINUX {
			if !strings.HasSuffix(filename, ".elf") {
				filename += ".elf"
			}

			payloadPath += "thanatos"
		} else {
			if !strings.HasSuffix(filename, ".exe") {
				filename += ".exe"
			}

			payloadPath += "thanatos.exe"
		}
	} else if strings.Contains(output, "shared library") {
		if payloadBuildMsg.SelectedOS == agentstructs.SUPPORTED_OS_LINUX {
			if !strings.HasSuffix(filename, ".so") {
				filename += ".so"
			}

			payloadPath += "libthanatoslib.so"
		} else {
			if !strings.HasSuffix(filename, ".dll") {
				filename += ".dll"
			}

			payloadPath += "thanatoslib.dll"
		}
	} else if strings.Contains(output, "shellcode") {
	}

	payloadData := []byte{}

	if payloadData, err = os.ReadFile(payloadPath); err != nil {
		payloadBuildResponse.BuildMessage = fmt.Sprintf("Failed to find payload path: %s", payloadPath)
		return payloadBuildResponse
	}

	buildLock.Unlock()

	payloadBuildResponse.Success = true
	payloadBuildResponse.BuildMessage = "Successfully built thanatos agent."
	payloadBuildResponse.BuildStdOut = commandString

	payloadBuildResponse.UpdatedFilename = &filename
	payloadBuildResponse.Payload = &payloadData

	return payloadBuildResponse
}

func Initialize() {
	agentstructs.AllPayloadData.Get("thanatos").AddPayloadDefinition(payloadDefinition)
	agentstructs.AllPayloadData.Get("thanatos").AddIcon(filepath.Join(".", "thanatos", "icon", "thanatos.svg"))
	agentstructs.AllPayloadData.Get("thanatos").AddBuildFunction(buildPayload)
}
